knitr::opts_chunk$set(echo = TRUE)
library(MASS)
head(survey)
mu = 5                                # Média da amostra, valor dado
sigma = 2                             # Desvio padrão conhecido da população
n = 20                                # Tamanho da amostra
stdm =  sigma/sqrt(n)                 # Desvio padrão da média da amostra (std mean)
error = qnorm(0.975)*stdm; error
xbar= c(mu - error, mu + error); xbar
mu = mean(survey$Height, na.rm=TRUE)  # Média da amostra
sigma = sd(survey$Height, na.rm=TRUE) # Desvio padrão da amostra
n = sum(!is.na(survey$Height))        # Tamanho da amostra
stdm =  sigma / sqrt(n)               # ESTIMATIVA do desvio padrão da média da amostra (std mean)
error = qt(0.975, df= n - 1 )*stdm; error
xbar= c(mu - error, mu + error); xbar
mu = 5                                # Média da amostra, valor dado
sigma = 2                             # Desvio padrão conhecido da população
n = 20                                # Tamanho da amostra
stdm =  sigma/sqrt(n)                 # Desvio padrão da média da amostra (std mean)
error = qnorm(0.975)*stdm; error
xbar= c(mu - error, mu + error); xbar
library(MASS)
head(survey)
mu = 5                                # Média da amostra, valor dado
sigma = 2                             # Desvio padrão conhecido da população
n = 20                                # Tamanho da amostra
stdm =  sigma/sqrt(n)                 # Desvio padrão da média da amostra (std mean)
error = qnorm(0.975)*stdm; error
xbar= c(mu - error, mu + error); xbar
mu = mean(survey$Height, na.rm=TRUE)  # Média da amostra
sigma = sd(survey$Height, na.rm=TRUE) # Desvio padrão da amostra
n = sum(!is.na(survey$Height))        # Tamanho da amostra
stdm =  sigma / sqrt(n)               # ESTIMATIVA do desvio padrão da média da amostra (std mean)
error = qt(0.975, df= n - 1 )*stdm; error
xbar= c(mu - error, mu + error); xbar
head(ToothGrowth)
help(ToothGrowth)
# Calculando o intervalo de confiança para a média de len
confidence_interval <- t.test(ToothGrowth$len, conf.level = 0.95)$conf.int
confidence_interval
# Carregando a base de dados
data(ToothGrowth)
# Calculando o intervalo de confiança para len com 95% de confiança
conf_interval <- t.test(ToothGrowth$len)$conf.int
conf_interval
# Calculando o intervalo de confiança para len com 98% de confiança
conf_interval_98 <- t.test(ToothGrowth$len, conf.level = 0.98)$conf.int
conf_interval_98
# Criando uma sequência de níveis de confiança de 50% a 99%
conf_levels <- seq(0.50, 0.99, by = 0.01)
# Lista para armazenar os valores de E
errors <- c()
# Calculando o erro para cada nível de confiança
for (conf_level in conf_levels) {
conf_interval <- t.test(ToothGrowth$len, conf.level = conf_level)$conf.int
error <- (conf_interval[2] - conf_interval[1]) / 2
errors <- c(errors, error)
}
# Plotando o gráfico
plot(conf_levels * 100, errors, type = "l", xlab = "Nível de Confiança (%)", ylab = "Erro (E)")
abline(v = 98, col = "red")  # Linha vertical para o intervalo de 98%
# Carregando a base de dados
bitcoin <- read.csv('https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/3_TwoNumOrdered.csv', sep=' ', header=TRUE)
# Calculando o intervalo de confiança para toda a série histórica do valor do Bitcoin
conf_interval <- t.test(bitcoin$value)$conf.int
conf_interval
# Convertendo a coluna 'Date' para o formato de data
bitcoin$Date <- as.Date(bitcoin$Date, format = "%Y-%m-%d")
head(bitcoin)
str(bitcoin)
# Convertendo a coluna 'Date' para o formato de data
bitcoin$Date <- as.Date(bitcoin$date)
# Criando o atributo 'year'
bitcoin$year <- format(bitcoin$Date, "%Y")
# Obtendo os anos únicos
unique_years <- unique(bitcoin$year)
# Lista para armazenar os intervalos de confiança por ano
conf_intervals_by_year <- list()
# Calculando o intervalo de confiança para cada ano
for (year in unique_years) {
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- t.test(bitcoin_year$value)$conf.int
conf_intervals_by_year[[year]] <- conf_interval
}
# Criando um gráfico para cada ano com o intervalo de confiança
par(mfrow = c(length(unique_years), 1), mar = c(4, 4, 2, 1))
for (i in 1:length(unique_years)) {
year <- unique_years[i]
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- conf_intervals_by_year[[year]]
plot(bitcoin_year$Date, bitcoin_year$value, type = "l", ylim = range(bitcoin$value),
main = paste("Intervalo de Confiança (95%) para o Ano", year),
xlab = "Data", ylab = "Valor do Bitcoin", col = "blue")
abline(h = conf_interval, lty = 2, col = "red")
}
# Convertendo a coluna 'Date' para o formato de data
bitcoin$Date <- as.Date(bitcoin$date)
# Criando o atributo 'year'
bitcoin$year <- format(bitcoin$Date, "%Y")
# Obtendo os anos únicos
unique_years <- unique(bitcoin$year)
# Lista para armazenar os intervalos de confiança por ano
conf_intervals_by_year <- list()
# Calculando o intervalo de confiança para cada ano
for (year in unique_years) {
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- t.test(bitcoin_year$value)$conf.int
conf_intervals_by_year[[year]] <- conf_interval
}
# Criando um gráfico para cada ano com o intervalo de confiança
# Ajustando as margens da figura
par(mfrow = c(length(unique_years), 1), mar = c(2, 4, 2, 1))
# Criando os gráficos para cada ano com o intervalo de confiança
for (i in 1:length(unique_years)) {
year <- unique_years[i]
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- conf_intervals_by_year[[year]]
plot(bitcoin_year$Date, bitcoin_year$value, type = "l", ylim = range(bitcoin$value),
main = paste("Intervalo de Confiança (95%) para o Ano", year),
xlab = "Data", ylab = "Valor do Bitcoin", col = "blue")
abline(h = conf_interval, lty = 2, col = "red")
}
# Carregando a base de dados
bitcoin <- read.csv('https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/3_TwoNumOrdered.csv', sep=' ', header=TRUE)
# Verificando os nomes das colunas
names(bitcoin)
# Renomeando a coluna 'date'
names(bitcoin)[1] <- "Date"
# Convertendo a coluna 'Date' para o formato de data
bitcoin$Date <- as.Date(bitcoin$Date, format = "%Y-%m-%d")
# Criando o atributo 'year'
bitcoin$year <- format(bitcoin$Date, "%Y")
# Obtendo os anos únicos
unique_years <- unique(bitcoin$year)
# Lista para armazenar os intervalos de confiança por ano
conf_intervals_by_year <- list()
# Calculando o intervalo de confiança para cada ano
for (year in unique_years) {
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- t.test(bitcoin_year$value)$conf.int
conf_intervals_by_year[[year]] <- conf_interval
}
# Criando um gráfico para cada ano com o intervalo de confiança
par(mfrow = c(length(unique_years), 1), mar = c(4, 4, 2, 1))
for (i in 1:length(unique_years)) {
year <- unique_years[i]
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- conf_intervals_by_year[[year]]
plot(bitcoin_year$Date, bitcoin_year$value, type = "l", ylim = range(bitcoin$value),
main = paste("Intervalo de Confiança (95%) para o Ano", year),
xlab = "Data", ylab = "Valor do Bitcoin", col = "blue")
abline(h = conf_interval, lty = 2, col = "red")
}
# Convertendo a coluna 'date' para o formato de data
bitcoin$Date <- as.Date(bitcoin$date, format = "%Y-%m-%d")
# Criando o atributo 'year'
bitcoin$year <- format(bitcoin$Date, "%Y")
# Obtendo os anos únicos
unique_years <- unique(bitcoin$year)
# Lista para armazenar os intervalos de confiança por ano
conf_intervals_by_year <- list()
# Calculando o intervalo de confiança para cada ano
for (year in unique_years) {
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- t.test(bitcoin_year$value)$conf.int
conf_intervals_by_year[[year]] <- conf_interval
}
# Criando um gráfico para cada ano com o intervalo de confiança
par(mfrow = c(length(unique_years), 1), mar = c(4, 4, 2, 1))
for (i in 1:length(unique_years)) {
year <- unique_years[i]
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- conf_intervals_by_year[[year]]
plot(bitcoin_year$Date, bitcoin_year$value, type = "l", ylim = range(bitcoin$value),
main = paste("Intervalo de Confiança (95%) para o Ano", year),
xlab = "Data", ylab = "Valor do Bitcoin", col = "blue")
abline(h = conf_interval, lty = 2, col = "red")
}
# Criando o atributo 'year'
bitcoin$year <- format(bitcoin$Date, "%Y")
# Obtendo os anos únicos
unique_years <- unique(bitcoin$year)
# Lista para armazenar os intervalos de confiança por ano
conf_intervals_by_year <- list()
# Calculando o intervalo de confiança para cada ano
for (year in unique_years) {
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- t.test(bitcoin_year$value)$conf.int
conf_intervals_by_year[[year]] <- conf_interval
}
# Criando um gráfico para cada ano com o intervalo de confiança
# Criando um gráfico para cada ano com o intervalo de confiança
par(mfrow = c(length(unique_years), 1), mar = c(4, 4, 2, 1))
for (i in 1:length(unique_years)) {
year <- unique_years[i]
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- conf_intervals_by_year[[year]]
# Ajustando as margens do gráfico
par(mar = c(4, 4, 2, 1))
plot(bitcoin_year$Date, bitcoin_year$value, type = "l", ylim = range(bitcoin$value),
main = paste("Intervalo de Confiança (95%) para o Ano", year),
xlab = "Data", ylab = "Valor do Bitcoin", col = "blue")
abline(h = conf_interval, lty = 2, col = "red")
}
# Criando o atributo 'year'
bitcoin$year <- format(bitcoin$Date, "%Y")
# Obtendo os anos únicos
unique_years <- unique(bitcoin$year)
# Lista para armazenar os intervalos de confiança por ano
conf_intervals_by_year <- list()
# Calculando o intervalo de confiança para cada ano
for (year in unique_years) {
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- t.test(bitcoin_year$value)$conf.int
conf_intervals_by_year[[year]] <- conf_interval
}
# Criando um gráfico para cada ano com o intervalo de confiança
# Criando um gráfico para cada ano com o intervalo de confiança
par(mfrow = c(length(unique_years), 1), mar = c(4, 4, 2, 1))
# Loop para criar um gráfico para cada ano com o intervalo de confiança
for (i in 1:length(unique_years)) {
year <- unique_years[i]
bitcoin_year <- bitcoin[bitcoin$year == year, ]
conf_interval <- conf_intervals_by_year[[year]]
# Criando uma nova janela gráfica para cada ano
plot.new()
plot.window(xlim = range(bitcoin_year$Date), ylim = range(bitcoin$value))
title(main = paste("Intervalo de Confiança (95%) para o Ano", year))
lines(bitcoin_year$Date, bitcoin_year$value, type = "l", col = "blue")
abline(h = conf_interval, lty = 2, col = "red")
}
# Convertendo a coluna 'date' para o formato de data
bitcoin$date <- as.Date(bitcoin$date)
# Carregando a base de dados
# Carregando os dados do Bitcoin
bitcoin <- read.csv('https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/3_TwoNumOrdered.csv', sep=' ', header=T)
# Calculando o intervalo de confiança
t_stat <- qt(0.975, df = nrow(bitcoin) - 1)
std_err <- sd(bitcoin$value) / sqrt(nrow(bitcoin))
conf_int <- c(mean(bitcoin$value) - t_stat * std_err, mean(bitcoin$value) + t_stat * std_err)
# Apresentando o intervalo de confiança
print(conf_int)
# Criando o atributo 'year'
bitcoin$year <- lubridate::year(bitcoin$date)
install.packages("lubridate")
library(lubridate)
# Criando o atributo 'year'
bitcoin$year <- lubridate::year(bitcoin$date)
library(lubridate)
# Criando o atributo 'year'
bitcoin$year <- lubridate::year(bitcoin$date)
# Carregando a base de dados
# Carregando os dados do Bitcoin
bitcoin <- read.csv('https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/3_TwoNumOrdered.csv', sep=' ', header=T)
# Calculando o intervalo de confiança
t_stat <- qt(0.975, df = nrow(bitcoin) - 1)
std_err <- sd(bitcoin$value) / sqrt(nrow(bitcoin))
conf_int <- c(mean(bitcoin$value) - t_stat * std_err, mean(bitcoin$value) + t_stat * std_err)
# Apresentando o intervalo de confiança
print(conf_int)
library(lubridate)
# Criando o atributo 'year'
bitcoin$year <- lubridate::year(bitcoin$date)
# Anos únicos
anos_unicos <- unique(bitcoin$year)
# Intervalo de confiança para cada ano
intervalos_confianca <- lapply(anos_unicos, function(ano) {
# Selecionando dados do ano específico
dados_ano <- bitcoin[bitcoin$year == ano, ]
# Calculando intervalo de confiança
t_stat <- qt(0.975, df = nrow(dados_ano) - 1)
std_err <- sd(dados_ano$value) / sqrt(nrow(dados_ano))
conf_int_ano <- c(mean(dados_ano$value) - t_stat * std_err, mean(dados_ano$value) + t_stat * std_err)
# Retornando intervalo de confiança
conf_int_ano
})
# Definindo cores para os intervalos de confiança
cores <- rep('blue', length(anos_unicos))
# Criando o gráfico
plot(bitcoin$year, bitcoin$value, main = 'Valor do Bitcoin por Ano', xlab = 'Ano', ylab = 'Valor (USD)')
# Adicionando linhas dos intervalos de confiança
for (i in 1:length(anos_unicos)) {
ano <- anos_unicos[i]
conf_int <- intervalos_confianca[[i]]
lines(c(ano, ano), conf_int, col = cores[i])
}
# Adicionando pontos dos valores médios anuais
points(anos_unicos, mean(bitcoin[bitcoin$year == anos_unicos, ]$value), pch = 16, col = 'red')
# Definindo cores para os intervalos de confiança
cores <- rep('blue', length(anos_unicos))
# Criando o gráfico
plot(bitcoin$year, bitcoin$value, main = 'Valor do Bitcoin por Ano', xlab = 'Ano', ylab = 'Valor (USD)')
# Adicionando linhas dos intervalos de confiança
for (i in 1:length(anos_unicos)) {
ano <- anos_unicos[i]
conf_int <- intervalos_confianca[[i]]
# Criando o vetor 'y' com o mesmo comprimento que 'x'
y_ano <- rep(NA, length(bitcoin$year[bitcoin$year == ano]))
y_ano[which(bitcoin$year == ano)] <- conf_int
lines(bitcoin$year[bitcoin$year == ano], y_ano, col = cores[i])
}
# Definindo cores para os intervalos de confiança
cores <- rep('blue', length(anos_unicos))
# Criando o gráfico
plot(bitcoin$year, bitcoin$value, main = 'Valor do Bitcoin por Ano', xlab = 'Ano', ylab = 'Valor (USD)')
# Adicionando linhas dos intervalos de confiança
for (i in 1:length(anos_unicos)) {
ano <- anos_unicos[i]
conf_int <- intervalos_confianca[[i]]
# Criando o vetor 'y' com o mesmo comprimento que 'x'
y_ano <- rep(NA, length(bitcoin$year[bitcoin$year == ano]))
y_ano[which(bitcoin$year == ano)] <- conf_int
lines(bitcoin$year[bitcoin$year == ano], y_ano, col = cores[i])
}
# Carregando a base de dados
bitcoin <- read.csv('https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/3_TwoNumOrdered.csv', sep=' ', header=T)
# Criando o atributo 'year'
bitcoin$year <- as.integer(format(as.Date(bitcoin$date), "%Y"))
# Obtendo os anos únicos
anos <- unique(bitcoin$year)
# Inicializando um vetor para armazenar os intervalos de confiança por ano
conf_intervals <- vector("list", length(anos))
# Calculando o intervalo de confiança para cada ano
for (i in 1:length(anos)) {
subset_bitcoin <- bitcoin[bitcoin$year == anos[i], ]
t_stat <- qt(0.975, df = nrow(subset_bitcoin) - 1)
std_err <- sd(subset_bitcoin$value) / sqrt(nrow(subset_bitcoin))
conf_intervals[[i]] <- c(mean(subset_bitcoin$value) - t_stat * std_err, mean(subset_bitcoin$value) + t_stat * std_err)
}
# Plotando os intervalos de confiança para cada ano
par(mfrow=c(1,1)) # Definindo layout de gráfico
for (i in 1:length(anos)) {
plot(conf_intervals[[i]], type='l', ylim=c(min(unlist(conf_intervals)), max(unlist(conf_intervals))), xlab='Year', ylab='Bitcoin Value', main=paste('Intervalo de Confiança - Ano', anos[i]))
}
# Separando os dados em dois grupos: população urbana acima de 50% e abaixo ou igual a 50%
urban_high <- USArrests[USArrests$UrbanPop > 50, "Murder"]
urban_low <- USArrests[USArrests$UrbanPop <= 50, "Murder"]
# Calculando os intervalos de confiança para cada grupo
conf_int_high <- t.test(urban_high)$conf.int
conf_int_low <- t.test(urban_low)$conf.int
# Apresentando os intervalos de confiança
print("Intervalo de Confiança para População Urbana acima de 50%:")
print(conf_int_high)
print("Intervalo de Confiança para População Urbana abaixo ou igual a 50%:")
print(conf_int_low)
# Realizando o teste t para comparar as médias dos dois grupos
t_test_result <- t.test(urban_high, urban_low)
print("Resultado do Teste t:")
print(t_test_result)
library(MASS)
head(survey)
mu = 5                                # Média da amostra, valor dado
sigma = 2                             # Desvio padrão conhecido da população
n = 20                                # Tamanho da amostra
stdm =  sigma/sqrt(n)                 # Desvio padrão da média da amostra (std mean)
error = qnorm(0.975)*stdm; error
xbar= c(mu - error, mu + error); xbar
mu = mean(survey$Height, na.rm=TRUE)  # Média da amostra
sigma = sd(survey$Height, na.rm=TRUE) # Desvio padrão da amostra
n = sum(!is.na(survey$Height))        # Tamanho da amostra
stdm =  sigma / sqrt(n)               # ESTIMATIVA do desvio padrão da média da amostra (std mean)
error = qt(0.975, df= n - 1 )*stdm; error
xbar= c(mu - error, mu + error); xbar
# Gerando duas amostras de distribuição normal idênticas
x <- rnorm(25)
y <- rnorm(25)
# Realizando o teste t
result <- t.test(x, y)
print("Valor de t:")
print(result$statistic)
print("Valor de p-value:")
print(result$p.value)
p = c(0)
for (i in 1:100){
x = rnorm(25, mean = 100, sd = 10); # x
y = rnorm(25, mean = 101, sd = 10); # y
result = t.test(x,y)
# names(result)
if (result$p.value < 0.05) print(result$p.value)
p[i] = result$p.value
}
plot(log(p),col='blue')
for (i in 1:100){
if (p[i] < 0.05) lines(i,log(p[i]),pch=15,type='b',col='red')
}
abline(h=log(0.05),col='red',lty=2)
text(50,log(0.07),'p-values acima de 0.05... Aceita Hipótese nula, médias iguais')
text(50,log(0.03),'p-values abaixo de 0.05... Aceita Hipótese alternativa, médias diferentes')
x <- rnorm(25, mean = 100, sd = 2.5)
y <- rnorm(25, mean = 101, sd = 2.5)
p_values <- c()
# Realizando o teste t em 100 experimentos
for (i in 1:100) {
result <- t.test(x, y)
p_values <- c(p_values, result$p.value)
}
# Plotando os valores de p-values
plot(log(p_values), col = 'blue', xlab = 'Experimento', ylab = 'log(p-value)')
abline(h = log(0.05), col = 'red', lty = 2)
for (i in 1:100) {
if (p_values[i] < 0.05) {
points(i, log(p_values[i]), pch = 15, type = 'b', col = 'red')
}
}
text(50, log(0.07), 'p-values acima de 0.05... Aceita Hipótese nula, médias iguais')
text(50, log(0.03), 'p-values abaixo de 0.05... Aceita Hipótese alternativa, médias diferentes')
# Definindo as amostras
x <- rnorm(25, mean = 100, sd = 2.5)
y <- rnorm(25, mean = 101, sd = 2.5)
# Realizando o teste t
result <- t.test(x, y)
# Exibindo o resultado
print(result)
# Definindo as amostras
x <- rnorm(25, mean = 100, sd = 2.5)
y <- rnorm(25, mean = 101, sd = 2.5)
p <- c(0)
for (i in 1:100){
x <- rnorm(25, mean = 100, sd = 2.5)
y <- rnorm(25, mean = 101, sd = 2.5)
result <- t.test(x, y)
if (result$p.value < 0.05) print(result$p.value)
p[i] <- result$p.value
}
plot(log(p), col = 'blue')
for (i in 1:100){
if (p[i] < 0.05) lines(i, log(p[i]), pch = 15, type = 'b', col = 'red')
}
abline(h = log(0.05), col = 'red', lty = 2)
text(50, log(0.07), 'p-values acima de 0.05... Aceita Hipótese nula, médias iguais')
text(50, log(0.03), 'p-values abaixo de 0.05... Aceita Hipótese alternativa, médias diferentes')
# Definindo as amostras
x <- rnorm(25, mean = 100, sd = 2.5)
y <- rnorm(25, mean = 101, sd = 2.5)
p <- c(0)
for (i in 1:100){
x <- rnorm(25, mean = 100, sd = 2.5)
y <- rnorm(25, mean = 101, sd = 2.5)
result <- t.test(x, y)
if (result$p.value < 0.05) print(result$p.value)
p[i] <- result$p.value
}
plot(log(p), col = 'blue')
for (i in 1:100){
if (p[i] < 0.05) lines(i, log(p[i]), pch = 15, type = 'b', col = 'red')
}
abline(h = log(0.05), col = 'red', lty = 2)
text(50, log(0.07), 'p-values acima de 0.05... Aceita Hipótese nula, médias iguais')
text(50, log(0.03), 'p-values abaixo de 0.05... Aceita Hipótese alternativa, médias diferentes')
set.seed(1234)
x = rnorm(25, mean = 100, sd = 12); x
mean(x)
# Realizando o teste t
result <- t.test(x, mu = 100)
# Extraindo o valor-p
p_value <- result$p.value
# Verificando se o p-value é menor que 0.05 (nível de significância de 95%)
if (p_value < 0.05) {
print("O peso médio das embalagens é estatisticamente diferente de 100g.")
} else {
print("O peso médio das embalagens não é estatisticamente diferente de 100g.")
}
# Apresentando o valor-p
print(p_value)
